---
layout: post
title: Core Java（9）集合
categories: Core Java
permalink: /:categories/9
---

## Java 集合框架

Java 最初的版本只为最常用的数据结构提供了很少的一组类：Vector、Stack、Hashtable、BitSet 与 Enumeration 接口，其中的 Enumeration 接口提供了一种用于访问任意容器的各个元素的抽象机制。

随着 Java 1.2 问世，设计人员开始尝试推出一组功能完善的数据结构。

与现代的数据结构类库的常见做法一样，Java 集合类库也将接口与实现分离。根据不同的算法会有不一样的实现类，如链表结构或者数组结构。在 API 文档中，还有一组名字以 Abstract 开头的抽象类，这些类是为类库实现者而设计的，扩展 Abstract 类要比直接实现接口要轻松的多。

### Collection 接口

集合类的基本接口是 Collection 接口。这个接口有两个基本方法：
```java
public interface Collection<E>{
    boolean add(E element);
    Iterator<E> iterator();
    ...
}
```
add 方法用于向集合中添加元素。如果添加元素确实改变了集合就返回 true；如果集合没有发生变化就返回 false。

iterator 方法用于返回一个实现了 Iterator 接口的对象。可以使用这个迭代器对象依次访问几个中的元素。

### 迭代器

Iterator 接口包含 4 个方法：
```java
public interface Iterator<E>{
    E next();
    boolean hasNext();
    void remove();
    default void forEachRemaining(Consumer<? super E> action);
}
```

通过反复调用 next 方法，可以逐个访问集合中的元素。但是，如果到达了集合的末尾，next 方法将抛出一个 NoSuchElementException。因此，需要在调用 next 之前调用 hasNext 方法。如果迭代器对象还有多个可以访问的元素，这个方法就返回 true。如果想要查看集合中的所有元素，就请求一个迭代器，当 hasNext 返回 true 时就反复地调用 next 方法。例如：
```java
Collection<String> c = ...;
Iterator<String> iter = c.iterator();
while(iter.hasNext()){
    String element = iter.next();
    ...
}
```
用 “for each” 循环可以更加简练地表示同样的循环操作：
```java
for(String element : c){
    ...
}
```
编译器简单地将 “for each” 循环转换为带有迭代器的循环。“for each” 循环可以处理任何实现了 Iterable 接口的对象，这个接口只包含一个抽象方法：
```java
public interface Iterable<E>{
    Iterator<E> iterator();
    ...
}
```
Collection 接口扩展了 Iterable 接口。也因此，对于标准类库中的任何集合都可以使用 “for each” 循环。

也可以不写循环，而是调用 forEachRemaining 方法传递一个 lambda 表达式，它会对迭代器的每一个元素调用这个 lambda 表达式，直到再没有元素为止。
```java
iterator.forEachRemaining(element -> {...})
```
访问元素的顺序取决于集合类型。

Java 集合类库中的迭代器与其他类库中的迭代器在概念上有着重要的区别。Java 迭代器查找一个元素的唯一方法就是调用 next, 而在执行查找操作的同时，迭代器的位置就会随之向前移动。

Java 迭代器位于两个元素之间。当调用 next 时，迭代器就越过下一个元素，并返回刚刚越过的那个元素的引用。

Iterator 接口的 remove 方法将会删除上次调用 next 方法时返回的元素。remove 方法和 next 方法之间存在依赖性，必须在调用 remove 方法之前调用一次 next 方法，否则将会抛出一个 IllegalStateException 异常。
```java
it.next();
it.remove(); // OK
it.remove(); // ERROR
```
连续调用两次 remove 方法不能删除两个相邻的元素，必须先调用 next 越过将要删除的元素。
```java
it.remove();
it.next();
it.remove(); // OK
```

### 泛型实用方法

由于 Collection 与 Iterator 都是泛型接口，这意味着你可以编写处理任何集合类型的实用方法。例如，下面是一个检测任意集合是否包含指定元素的泛型方法：
```java
public static <E> boolean contains(Collection<E> c, Object obj){
    for(E element : c)
        if(element.equals(obj))
            return true;
    return false;
}
```
Java 类库的设计者认为：这些实用方法中有一些非常有用，应该将它们提供给用户实用。这样，类库的使用者就不必自己重新构建这些方法了。contains 就是这样一个实用方法。

事实上，Collection 接口声明了很多有用的方法，所有的实现类都必须提供这些方法。下面列举了其中一部分：
```java
int size()
boolean isEmpty()
boolean contains(Object obj)
boolean containsAll(Collection<?> c)
boolean equals(Object obj)
boolean addAll(Collection<? extends E> from)
boolean remove(Object obj)
boolean removeAll(Collection<?> c)
void clear()
boolean retainAll(Collection<?> c)
Object[] toArray()
<T> T[] toArray(T[] arrayToFill)
```
当然，如果要实现 Collection 接口的每一个类都要提供如此多的例行方法，这将很麻烦。为了能够让实现者更容易地实现这个接口，Java 类库提供了一个类 AbstractCollection，它保持基础方法 size 和 iterator 仍为抽象方法，但是为实现者实现了其他的例行方法。

这样一来，具体集合类可以扩展 AbstractCollection 类。具体的集合类只需提供 iterator 等方法，而其他方法则由父类提供，当然，如果子类有更高效的方式也可以重写这些方法。

这种做法似乎有些过时了，这些方法最好是 collection 接口的默认方法，但实际上虽然确实增加了很多默认方法，其中大部分方法都与流的处理有关。另外还有一个很有用的方法：
```java
default boolean removeIf(Predicate<? super E> filter)
```
这个方法用于删除满足某个条件的元素。

## 集合框架中的接口

Java 集合有两个基本接口：Collection 和 Map。

Map 映射包含键/值对，所以要用 put 方法来插入：`V put(K key, V value)` 。要从映射读取元素则要用 get 方法:`V get(K key)` 。

除了以 Map 结尾的类之外，其他类都实现了 Collection 接口。

|集合类型|描述|
|:-----:|:-:|
|ArrayList|可以动态增长和缩减的一个索引序列|
|LinkedList|可以在任何位置高效插入和删除的一个有序序列|
|ArrayDeque|实现为循环数组的一个双端队列|
|HashSet|没有重复元素的一个无序集合|
|TreeSet|一个有序集|
|EnumSet|一个包含枚举类型值的集|
|LinkedHashSet|一个可以记住元素插入次序的集|
|PriorityQueue|允许高效删除最小元素的一个集合|
|HashMap|存储键/值关联的一个数据结构|
|TreeMap|键有序的一个映射|
|EnumMap|键属于枚举类型的一个映射|
|LinkedHashMap|可以记住键/值项添加次序的一个映射|
|WeakHashMap|值不会在别处使用时就可以被垃圾回收的一个映射|
|IdentityHashMap|用==而不是用equals比较键的一个映射|

### 链表

在 Java 中，所有链表（linked list）都是双向链表（doubly linked）——即包含前驱和后驱的链接引用。

链表是一个 *有序集合*（ordered collection），每个对象的位置十分重要。LinkedList.add 方法将对象添加到链表的尾部。迭代器描述了集合中的位置，依赖于位置的 add 方法将由迭代器负责。只有对自然有序的集合使用迭代器添加元素才有实际意义。因此，Iterator 接口中没有 add 方法。实际上，集合类库提供了一个子接口 ListIterator,其中包含 add 方法：
```java
interface ListIterator<E> extends Iterator<E> {
    void add(E);
    void remove();
    E next();
    boolean hasNext();
    void set(E);
    int nextIndex();
    E previous();
    int previousIndex();
    boolean hasPrevious();
}
```
与 Collection.add 不同，这个方法不返回 boolean 类型的值，它假定 add 操作总会改变链表。

另外，其 previous 方法和 hasPrevious 方法可以反向遍历链表。与 next 方法一样，previous 方法返回越过的对象。

LinkedList 类的 listIterator 方法返回一个实现了 ListIterator 接口的迭代器对象，add 方法在迭代器位置之前添加一个新对象。例如，下面的代码将越过第一个元素，在第二个元素之前添加新元素。
```java
ListIterator<String> iter = staff.llistIterator();
iter.next(); // skip past first element
iter.add("Juliet");
```
如果多次调用 add 方法，将按照提供的次序把元素添加到链表中。他们被依次添加到迭代器当前位置之前。

set 方法用一个新元素替换调用 next 或 previous 方法返回的上一个元素。
```java
ListIterator<String> iter = staff.llistIterator();
String oldValue = iter.next(); // returns first element
iter.set(newValue); // sets first element to newValue
```

考虑并发时的场景，假设一个迭代器指向一个元素前面的位置，而另一个迭代器刚刚删除了这个元素，现在前一个迭代器就是无效的，并且不能使用。链表迭代器设计为可以检测到这种修改。如果一个迭代器发现它的集合被另一个迭代器修改了，或是被该集合自身的某个方法修改了，就会抛出一个 ConcurrentModificationException 异常。例如，考虑下面这段代码：
```java
List<String> list = ...;
ListIterator<String> iter1 = list.listIterator();
ListIterator<String> iter2 = list.listIterator();
iter1.next();
iter1.remove();
iter2.next(); // throws ConcurrenModificationException
```
为了避免并发修改异常，请遵循这样一个简单的规则：可以根据需要为一个集合关联多个迭代器，前提是这些迭代器只能读取集合。或者，可以再关联一个能同时读写的迭代器。

有一种简单的方法可以检测到并发修改。集合可以跟踪更改操作（添加或删除元素）的次数。每个迭代器都会为它负责的更改操作维护一个单独的更改操作数。在每个迭代器方法的开始处，迭代器会检查它自己的更改操作数是否与集合的更改操作数相等。如果不一致，就抛出一个 ConcurrentModificationException 异常。（注释：链表只跟踪对列表的结构性修改，如添加和删除链接。set 方法不被视为结构性修改。）

链表不支持快速随机访问。如果要查看链表的第 n 个元素，就必须从头开始，复杂度为 n-1 。因此，需要按整数索引访问元素时，通常不选用链表。使用链表的唯一理由是尽可能地减少在列表中间插入或删除元素的开销。

下例程序创建了两个链表，将它们合并在一起，然后从第二个列表中没间隔一个元素删除一个元素，最后测试了 removeAll 方法。
```java
package linkedList;

import java.util.*;

public class LinkedListTest{
    public static void main(String[] args) {
        var a = new LinkedList<String>();
        a.add("Amy");
        a.add("Carl");
        a.add("Erica");

        var b = new LinkedList<String>();
        b.add("Bob");
        b.add("Doug");
        b.add("Frances");
        b.add("Gloria");

        // merge the words from b into a

        ListIterator<String> aIter = a.listIterator();
        Iterator<String> bIter = b.iterator();

        while(bIter.hasNext())
        {
            if (aIter.hasNext()) aIter.next();
            aIter.add(bIter.next());
        }

        System.out.println(a);

        // remove every second word from b

        bIter = b.iterator();
        while(bIter.hasNext()){
            bIter.next(); // skip one element
            if(bIter.hasNext())
            {
                bIter.next(); // skip next element
                bIter.remove(); // renive that element
            }
        }

        System.out.println(b);

        // bulk operation: remove all words in b from a

        a.removeAll(b);

        System.out.println(a);
        
    }
}
```

### 数组列表

ArrayList 类封装了一个动态再分配的对象数组。List 接口有两种访问元素的协议：一种是通过迭代器（如 LinkedList），另一种是通过 get 和 set 方法随机地访问每个元素。后者不适用与链表，但当然 get 和 set 方法对数组很有用。

ArrayList 类和 Vector 类都是动态数组，它们的区别是：ArrayList 类不是同步的，而 Vector 类的所有方法都是同步的，可以安全地从两个线程访问一个 Vector 对象，但是，如果只从一个线程访问 Vector,代码就会在同步操作上白白浪费大量的时间。因此，建议在不需要同步时使用 ArrayList，而不要使用 Vector。

### 散列表

在 Java 中，散列表用链表数组实现。每个列表被称为*桶*（bucket）。要想查找表中对象的位置，就要先计算它的散列码，然后与桶的对象取余，所得的结果就是保存这个元素的桶的索引。如果桶中没有元素，就直接插入到桶中；如果发生了散列冲突（hash collision），需要将新对象与桶中的所有对象进行比较，查看这个对象是否已经存在，如果不存在就插入到桶的链尾。如果散列码合理地随机分布，桶的数目也足够大，需要比较的次数就会很少。

在 Java 8 中，桶满时会从链表变为平衡二叉树。为了控制散列表的性能，需要指定一个初始的桶数，通常将桶数设置为预计元素个数的 75%～150%。标准类库使用的桶数是 2 的幂，默认值为 16。当然，并不总是能够知道需要存储多少个元素，装填因子（load factor）可以确定何时对散列表进行*再散列*（rehashed），装填因子默认为 0.75，说明表中已经填满了75%以上，就会自动再散列。

散列表可以用于实现很多重要的数据结构，其中最简单的就是集。Java 集合类库提供了一个 HashSet 类，它实现了基于散列将元素分散在表中，所以会以一种看起来随机的顺序访问元素。只有不关心集合中元素的顺序时才应该使用 HashSet。

下例代码使用一个 set 将 system.in 输入流中的单一单词打印出来：
```java
package set;

import java.util.*;

public class SetTest{
    public static void main(String[] args) {
        var words = new HashSet<String>();
        long totalTime = 0;
        
        try(var in = new Scanner(System.in))
        {
            while(in.hasNext())
            {
                String word = in.next();
                long callTime = System.currentTimeMillis();
                words.add(word);
                callTime = System.currentTimeMillis() - callTime;
                totalTime += callTime;
            }
        }
        Iterator<String> iter = words.iterator();
        for(int i = 1; i <= 20 && iter.hasNext(); i++)
            System.out.println(iter.next());
        System.out.println(". . .");
        System.out.println(words.size() + " distinct words. " + totalTime + " milliseconds.");
    }

}
```

## 具体集合

## 映射

## 视图与包装器

## 算法

## 遗留的集合