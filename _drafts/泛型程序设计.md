---
layout: post
title: Core Java（8）泛型程序设计
categories: Core Java
permalink: "/:categories/8"
---

## 为什么要使用泛型程序设计

*泛型程序设计*（generic programming）意味着编写的代码可以对多种不同类型的对象重用。例如 ArrayList 类可以收集任何类的对象，是泛型程序设计的典型例子。Java 5 引入的泛型是 Java 程序设计语言自最初发行以来最显著的变化。

在 Java 增加泛型类之前，泛型程序设计是用*继承*实现的。ArrayList 类只维护一个 Object 引用的数组，获取值时则要进行强制类型转换。使用泛型的*类型参数*（type parameter）使得代码具有更好的可读性，同时也告诉了编译器类型信息，不再需要进行强制类型转换。这比使用 Object 类型参数要安全的多

使用泛型会让程序更易读，也更安全。

## 定义简单泛型类

*泛型类*（generic class）就是有一个或多个类型变量的类。以一个简单的泛型 Pair 类作为例子：
```java
public class Pair<T>
{
    private T first;
    private T second;

    public Pair(){first = null; second = null;}
    public Pair(T first, T second){this.first = first; this.second = second;}

    public T getFirst(){return first;}
    public T getSecond(){return second;}

    public void setFirst(T newValue){first = newValue;}
    public void setSecond(T newValue){second = newValue;}
}
```

Pair 类引入了一个类型变量 T，用尖括号（<>）括起来，放在类名的后面，泛型类可以有多个类型变量，例如，可以定义两个类型变量 `class Pair<T, U>{...}`。类型变量在整个类定义中用于指定方法和返回类型以及字段和局部变量的类型。

## 泛型方法

除了可以定义泛型类，还可以定义一个带有类型参数的方法：
```java
class ArrayAlg{
    public static <T> T getMiddle(T... a){ return a[a.length / 2];}
}
```

这个方法是在普通方法中定义的，而不是在泛型类中。泛型方法可以在普通类中定义，也可以在泛型类中定义。要调用一个泛型方法，可以把具体类型包围在尖括号中，放在方法名前面：
```java
String middle = ArrayAllg.<String>getMiddle("John", "Q.", "Public");
```

在这种情况下，方法调用中可以省略 `<String>` 类型参数。编译器可以根据参数类型推断出返回类型。

## 类型变量的限定

有时，类或方法需要对类型变量加以约束。例如：
```java
class ArrayAlg{
    public static <T> T min(T[] a)
    {
        if (a == null || a.length == 0) return null;
        T smallest = a[0];
        for(int i = 1; i < a.length; i++)
            if (smallest.compareTo(a[i]) > 0) smallest = a[i];
        return smallest;
    }
}
```

在上面的代码中，min 方法有一个问题，那就是如何确定 T 变量类有 compareTo 方法。解决这个问题的方法是限定 T 只能是实现了 Comparable 接口的类。可以通过对类型参数 T 设置一个限定（bound）来实现这一点：
```java
public static <T extends Comparable> T min(T[] a){...}
```

`<T extends BoundingType>` 表示 T 应该是限定类型（bounding type）的子类型（subtype）。T 和限定类型可以是类，也可以是接口。选择关键字 extends 的原因是它更接近子类型的概念。

一个类型变量或通配符可以有多个限定，例如：`T extends Comparable & Serializable` 限定类型用 “&” 分隔，而逗号用来分隔类型变量。

## 泛型代码和虚拟机

虚拟机没有泛型类型对象，所有对象都属于普通类。

### 类型擦除

无论何时定义一个泛型类型，都会自动提供一个相应的*原始类型*（raw type）。这个原始类型的名字就是去掉类型参数后的泛型类型名。类型变量会被*擦除*（erased），并替换为限定类型（或者，对于无限定的变量的变量则替换为 Object）。

例如，`Pair<T>` 的原始类型如下所示：
```java
public class Pair{
    private Object first;
    private Object second;
    ...
}
```

因为 T 是一个无限定的变量，所以直接用 Object 替换。在程序中可以包含不同类型的 Pair，例如，Pair\<String> 或 Pair\<LocalDate>。不过擦出类型后，它们都会变成原始的 Pair 类型。

如果给定了限定，例如 `public class Interval<T extends Comparable & Serializable> implements Serializable` 的原始类型如下所示：
```java
public class Interval implements Serializable{
    private Comparable lower;
    private Comparable upper;
    ...
}
```
编译器会将第一个使用限定类型替换类型变量得到原始类型，为了提高效率，应该将标签（tagging）接口（即没有方法的接口）放在限定列表的末尾。

### 转换泛型表达式

编写一个泛型方法调用时，如果擦除了返回类型，编译器会插入强制类型转换。

### 转换泛型方法

类型擦除也会出现在泛型方法中。但是方法的擦除会带来一个问题，那就是继承方法可能会和泛型方法冲突，例如：
```java
class DateInterval extends Pair<LocalDate>
{
    public void setSecond(LocalDate second){...}
}
```
DateInterval 这个类擦除后还有另一个从 Pair 继承的 setSecond 方法，即 `public void setSecond(Object second)`。这显然是一个不同的方法，但是编译器会生成一个*桥方法*（bridge method）来解决这个问题：
```java
public void setSecond(Object second){ setSecond((LocalDate) second);}
```
虚拟机通过这种合成桥方法来解决类型擦除与多态的冲突。

## 限制与局限性

### 不能用基本类型实例化类型参数

不能用基本类型代替类型参数，其原因就在于类型擦除，擦除之后，泛型类含有 Object 类型的字段，而 Object 不能存储基本类型。这并不是一个很严重的问题，因为可以使用包装类代替。

### 运行时类型查询只适用于原始类型

虚拟机中的对象总有一个特定的非泛型类类型，因此，所有的类型查询只产生原始类型。例如，`a instanceof Pair<String>` 就会报错，实际上只能测试 a 是否是任意类型的一个 Pair。同样，`Pair<String> p = (Pari<String>) a` 进行强制类型转换会产生一个警告，强制类型转换只能转换一个原始类型的 Pair。

### 不能创建参数化类型的数组

不能实例化参数化类型的数组，例如：`var table = new Pair<String>[10]` 会报错。类型擦除之后，table 的类型是 Pair[]。可以把它转化为 Object[]：`Object[] objarray = table`。

数组会记住它的元素类型，如果试图存储其他元素类型的元素，就会抛出一个 `ArrayStoreException` 异常，不过，对于泛型类型，擦除会使这种机制无效，出于这个原因，不允许创建参数化类型的数组。

需要说明的是，只是不允许创建这些数组，而声明类型为 `Pair<String>[]` 的变量仍是合法的。不过不能用 `new Pair<String>[10]` 初始化这个变量。

如果需要收集参数化类型对象，简单地使用 ArrayList：`ArrayList<Pair<String>>` 更安全、有效。

### Varargs 警告

考虑下面这个简单的方法：
```java
public static <T> void addAll(Collection<T> coll, T... ts)
{
    for (T t:ts) coll.add(t);
}
```
方法 addAll 使用参数个数可变的泛型类型参数，ts 实际上是一个数组，而上一节我们知道 Java 虚拟机是不允许创建泛型数组的，然而，在本方法中，规则有所放松，你只会得到一个警告，而不是错误。

可以采用两种方法抑制这个警告。一种方法是为包含 addAll 调用的方法增加注解 `@SupperessWarnings("unchecked")`。或者在 Java 7 中，还可以用 `@SafeVarargs` 直接注解 addAll 方法。

`@SafeVarargs`注解只能用于声明为 static、final 或（Java 9 中）private 的构造器和方法。

### 不能实例化类型变量

不能在类似 `new T(...)` 的表达式中使用类型变量。例如，下面的构造器就是非法的：
```java
public Pair(){first = new T(); second = new T();}
```
类型擦除将 T 变成 Object，直接实例化就是调用 `new Object()`。

在 Java 8 之后，最好的解决方法是让调用者提供一个构造器表达式。例如：
```java
Pair<String> p = Pair.makePair(String::new);
```
makePair 方法接收一个 `Supplier<T>`，这是一个函数式接口，表示一个无参数而且返回类型为 T 的函数：
```java
public static <T> Pair<T> makePair(Supplier<T> constr){
    return new Pair<>(constr.get(), constr.get());
}
```
比较传统的解决方法是通过反射调用 `Constructor.newInstance` 方法来构造泛型对象，但是细节有点复杂。不能直接调用 `T.class.getConstructor().newInstance()` ，表达式 `T.class` 是不合法的，因为它会被擦除为 Object.class。必须适当地设计 API 以便得到一个 Class 对象，如：
```java
public static <T> Pair<T> makePair(Class<T> cl){
    try{
        return new Pair<>(cl.getConstructor().newInstance(), cl.getConstructor().newInstance());
    }catch(Exception e){ return null;}
}
```
这个方法可以调用 `Pair<String> p = Pair.makePair(String.class)`。注意，Class 类本身是泛型的。例如，String.class 是一个 `Class<String>` 的实例（事实上，它是唯一的实例）。因此，makePair 方法能够推断出所建立的对组（Pair）的类型。

### 不能构造泛型数组

和不能实例化泛型实例一样，也不能实例化数组。不过原因有所不同，毕竟数组可以填充 null 值，看上去好像可以安全地构造。不过，数组本身也带有类型，用来监控虚拟机中的数组存储。这个类型会被擦除。例如：
```java
public static <T extends Comparable> T[] minmax(T... a){
    T[] mm = new T[2] // ERROR
    ...
}
```
类型擦除会让这个方法总是构造 Comparable[2] 数组。

如果数组仅仅作为一个类的私有实例字段，那么可以将这个数组的元素类型声明为擦除的类型并使用强制转换。例如，Arraylist 类可以如下实现：
```java
public class ArrayList<E>{
    private Object[] elements;
    ...
    @SuppressWarnings("unchecked") public E get(int n){return (E) elements[n];}
    public void set(int n, E e){elements[n] = e;}
}
```
但实际实现没有这么清晰：
```java
public class ArrayList<E>{
    private E[] elements;
    ...
    public ArrayList(){elements = (E[]) new Object[10];}
}
```

这里，强制类型转换 E[] 是一个假象，而类型擦除使其无法察觉。这个技术并不适用于 minmax 方法，因为 minmax 方法返回一个 T[] 数组，如果类型不对，就会得到运行时错误结果。

在这种情况下，最好让用户提供一个数组构造器表达式：
```java
String [] names = ArrayAlg.minmax(String[]::new, "Tom", "Dick", "Harry");
```

构造器表达式 `String::new` 指示一个函数，给定所需的长度，就会构造一个指定长度的 String 数组。

minmax 方法使用这个参数生成一个有正确类型的数组：
```java
public static <T extends Comparable> T[] minmax(IntFunction<T[]> constr, T... a)
{
    T[] result = constr.apply(2);
    ...
}
```
比较老式的方法是利用反射，并调用 `Array.newInstance`:
```java
public static <T extends Comparable> T[] minmax(T... a){
    var result = (T[]) Array.newInstance(a.getClass().getComponentType(), 2);
    ...
}
```
ArrayList 类的 toArray 方法就没有这么幸运。它需要生成一个 T[] 数组，但没有元素类型。因此，有下面两种不同的形式：
```java
Object[] toArray()
T[] toArray(T[] result)
```
第二个方法接收一个数组参数，如果数组足够大，就使用这个参数，否则，用 result 的元素类型构造一个足够大的数组。

### 泛型类的静态上下文中类型变量无效

禁止使用带有类型变量的静态字段和方法。

### 不能抛出或捕获泛型类的实例

既不能抛出也不能捕获泛型类的对象。实际上，泛型类扩展 Throwable 甚至都是不合法的。

### 可以取消对检查型异常的检查

Java 异常处理的一个基本原则是，必须为所有检查型异常提供一个处理器。不过可以利用泛型取消这个机制。关键在于以下方法：
```java
@SuppressWarnings("unchecked")
static <T extends Throwable> void throwAs(Throwable t) throws T{
    throw (T) t;
}
```
假设这个方法包含在接口 Task 中，如果有一个检查型异常 e，并调用 `Task.<RuntimeException>throwAs(e);` 编译器就会认为 e 是一个非检查型异常。以下代码会把所有异常都转换为编译器所认为的非检查型异常：
```java
try{
    do work
}catch(Throwable t){
    Task.<RuntimeException>throwAs(t);
}
```
下面使用这个技术解决一个棘手的问题。要在一个线程中运行代码，需要把代码放在一个实现了 Runnable 接口的类的 run 方法中。不过这个方法不允许抛出检查型异常。我们将提供一个从 Task 到 Runnable 的适配器，它的 run 方法可以抛出任意异常。
```java
interface Task{
    void run() throws Exception;

    @SuppressWarnings("unchecked")
    static <T extends Throwable> void throwAs(Throwable t) throws T{
        throw (T) t;
    }

    static Runnable asRunnable(Task task)
    {
        return () ->
        {
            try{
                task.run();
            }catch(Exception e){
                Task.<RuntimeException>throwAs(e);
            }
        }
    }
}
```
这有什么意义呢？正产情况下，你必须捕获一个 Runnable 的 run 方法中的所有检查型异常，把它们 “包装” 到非检查型异常中，因为 run 方法声明为不抛出任何检查型异常。不过在这里并没有做这种 “包装”。我们只是抛出异常，并 “哄骗” 编译器，让它相信这不是一个检查型异常。

通过使用泛型类、擦除和 @SuppressWarnings 注解，我们就能消除 Java 类型系统的部分基本限制。

### 注意擦除后的冲突

当泛型类型被擦除后，不允许创建引发冲突的条件。假定 Pair 类增加一个 equals 方法，如下所示：
```java
public class Pair<T{
    public boolean equals(T value){return first.equals(value) && second.equals(value);}
}
```
考虑一个 `Pair<String>` ，从概念上讲，它有两个 equals 方法：
```
boolean equals(String) // defined in Pair<T>
boolean equals(String) // inherited from Object
```
但是，方法 `booelan equals(T)` 擦除后就是 `boolean equals(Object)` ，这会与 `Object.equals` 方法发生冲突。当然，补救的方法是重新命名引发冲突的方法。

泛型规范说明还引用了另外一个原则：“为了支持擦除转换，我们要施加一个限制：倘若两个接口类型是同一接口的不同参数化，一个类或类型变量就不能同时作为这两个接口类型的子类。”例如，下述代码是非法的：
```java
class Employee implements Comparable<Employee> {...}
class Manager extends Employee implements Comparable<Manager>{...} // ERROR
```
Manager 会实现 Comparable<Employee> 和 Comparable<Manager>，这是同一接口的不同参数化。其原因非常微妙，有可能与合成的桥方法产生冲突。

## 泛型类型的继承规则

## 通配符类型

## 反射和泛型
