---
layout: post
title: Core Java（5）继承
categories: Core Java
permalink: "/:categories/5"
---

## 类, 超类和子类

继承(inheritance)的基本思想是, 可以基于已有的类创建新的类. 以员工和经理为例, 从理论上讲, 在 Manager 与 Employee 之间存在着明显的 "is-a" (是)关系, 每个经理都是一个员工: "is-a" 关系是继承的一个明显特征.

要定义子类, 使用 extends 关键字表示继承
```java
public class Manager extends Employee{
    ...
}
```

关键字 extends 表明正在构造的新类派生于一个已存在的类. 这个已存在的类称为超类(superclass), 基类(base class)或父类(parent class); 新类称为子类(subclass), 派生类(derived class)或孩子类(child class). 超类和子类是 Java 程序员最常用的两个术语. "超"(super) 和 "子"(sub) 来源于计算机科学与数学理论中集合语言的术语.

子类可以继承超类全部字段和方法, 但值得注意的是子类并不能直接访问父类的私有成员变量, 子类只能通过调用父类的公共方法来获取这些私有的变量. 要想调用父类的方法和构造器, 需要使用 super 关键字, 和 this 关键字用法类似, 但是它其实是一个指示编译器调用超类方法的关键字, 而 this 是对当前对象的一个引用.

子类可以覆盖(ovverride) 超类的公共方法, 提供属于自己的方法, 也可以添加额外的成员方法和成员变量, 不过, 继承无法删除任何字段和方法.

### 多态

有一个简单规则可以判断是否应该将数据设计为继承关系, 这就是 "is-a" 规则, 它指出子类的每个对象也是超类的对象. 例如, 每个经理都是员工, 因此将 Manager 类设计为 Employee 类的子类是有道理的; 反之则不然, 并不是每一名员工都是经理.

"is-a" 规则的另一种表述是替换原则(substitution principle). 它指出程序中出现超类对象的任何地方都可以使用子类对象替换.

在 Java 程序设计语言中, 对象变量是多态的(polymorphic). 一个 Employee 类型的变量既可以引用一个 Employee 类型的对象, 也可以引用 Employee 类的任何一个子类的对象.例如
```java
Manager boss = new Manager(...);
Employee[] staff = new Employee[3];
staff[0] = boss;
```

在这个例子中, 变量 staff[0] 和 boss 引用同一个对象, 但编译器只将 staff[0] 看成是一个 Employee 对象.

这时如果使用 staff[0] 调用 Manager 的特有方法就会报错, 只能正常调用 Employee 的方法.

### 理解方法调用

假设要调用 x.f(args) , 隐式参数 x 声明为类 C 的一个对象. 下面是调用过程的详细描述:

1. 编译器查看对象的声明类型和方法名. 编译器会一一列举 C 类中的所有名为 f 的方法和其超类中所以名为 f 而且可访问的方法(超类的私有方法不可访问).
2. 接下来, 编译器要确定方法调用中提供的参数类型. 如果在所有名为 f 的方法中存在一个与所提供参数类型完全匹配的方法, 就选择这个方法, 这个过程称为重载解析(overloading resolution). 例如, 对于调用 x.f("Hello"), 编译器会挑选 f(String), 而不是 f(int). 至此, 编译器已经知道需要调用的方法的名字和参数类型.
3. 如果是 private/static/final 方法或者构造器，那么编译器将可以准确地知道应该调用哪个方法, 这称为静态绑定(static binding). 与此对应的是, 如果要调用的方法依赖于隐式参数的实际类型, 那么必须在运行时使用动态绑定.
4. 程序运行并且采用动态绑定调用方法时, 虚拟机必须调用与 x 所引用对象的实际类型对应的那个方法. 假设 x 的实际类型是 D, 它是 C 类的子类. 如果 D 类定义了方法 f(String), 就会调用这个方法; 否则, 将在 D 类的超类中寻找 f(String), 依次类推.
 
虚拟机预先为每个类计算了一个方法表(method table), 其中列出了所有方法的签名和要调用的实际方法. 这样一来, 在真正调用方法的时候, 虚拟机仅查找这个表就行了.

动态绑定有一个非常重要的特性: 无须对现有的代码进行修改就可以对程序进行扩展. 

### 阻止继承: final 类和方法

不允许扩展的类被称为 final 类, 如果在定义类的时候使用了 final 修饰符就表明这个类是 final 类. 例如:
```java
public final class Executive extends Manager
```
类中的某个方法也可以被声明为 final. 如果这样做, 子类就不能覆盖这个方法. 字段也可以声明为 final, 对于 final 字段来说, 构造对象之后就不允许改变它们的值了.

将方法或类声明为 final 的主要原因是: 确保它们不会在子类中改变语义.

### 强制类型转换

如果将一个子类的引用赋给一个超类变量, 编译器是允许的, 但将一个超类的引用赋给一个子类变量, 就承诺过多了. 必须进行强制类型转换, 这样才能通过运行时的检查. 只能在继承层次内进行强制类型转换, 不然就会产生一个 ClassCasterException 异常. 如果没有捕获这个异常, 那么程序就会终止. 在强制类型转换前, 应该检查是否能够成功地转换, 为此需要使用 instanceof 操作符. 例如:
```java
if(staffp[1] instanceof Manager){
    boss = (Manager) staff[1];
}
```

实际上, 通过强制类型转换对象的类型通常不是一种好的做法. 这意味着需要上调超类的方法, 当出现这种情况时, 需要思考的应该是超类的设计是否合理.

### 抽象类

抽象类是更高层次的抽象, 使用 abstract 修饰符的类称为抽象类, 修饰的方法称为抽象方法. 抽象方法只能在抽象类中定义, 抽象方法充当着占位方法的角色, 它们在子类中具体实现. 扩展抽象类可以有两种选择. 一种是在子类中保留抽象类中的部分或所有抽象方法仍未定义, 这样就必须把子类也标记为抽象类; 另一种做法是定义全部方法, 这样一来, 子类就不是抽象的了.
```java
public abstract class Person{
    ...
    public abstract String getDescription();
}
```

### 受保护访问

在有些时候, 你可能希望超类中的某个方法只允许子类访问, 或者更少见的, 可能希望允许子类的方法访问超类的某个字段. 为此, 需要将这些类方法或字段声明为受保护 (protected).

在 Java 中, 受保护字段只能由同一个包中的类访问. 在实际应用中, 要谨慎使用受保护字段, 因为它可以通过被继承的方式访问, 违背了 OOP 数据封装的静精神.

## Object: 所有类的超类

## 泛型数组列表

## 对象包装器与自动装箱

## 参数数量可变的方法

## 枚举类

## 反射

## 继承的设计技巧